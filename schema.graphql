# schema.graphql â€” UPDATED for your contracts + UI needs (safe superset)

enum RaffleStatus {
  OPEN
  DRAWING
  COMPLETED
  CANCELED
}

type Raffle @entity {
  id: Bytes!

  # --- canonical discovery (LotteryRegistry) ---
  isRegistered: Boolean!
  registry: Bytes
  registryIndex: BigInt
  typeId: BigInt
  registryCreator: Bytes
  registeredAt: BigInt
  registeredTxHash: Bytes
  registrationFailed: Boolean!

  # --- provenance ---
  deployer: Bytes!
  creator: Bytes!
  owner: Bytes!          # used for Admin button gating
  name: String!

  createdAtTimestamp: BigInt!
  createdAtBlock: BigInt!
  createdTxHash: Bytes!

  # --- config (from LotteryDeployed, plus one-time reads) ---
  usdc: Bytes!
  entropy: Bytes!
  entropyProvider: Bytes!
  feeRecipient: Bytes!
  protocolFeePercent: BigInt!

  ticketPrice: BigInt!
  winningPot: BigInt!
  deadline: BigInt!
  minTickets: BigInt!
  maxTickets: BigInt!
  minPurchaseAmount: BigInt!  # read once at creation via getter

  # --- state (display-only; confirm on-chain before signing) ---
  status: RaffleStatus!
  paused: Boolean!

  # --- display analytics (optional) ---
  sold: BigInt
  ticketRevenue: BigInt

  # --- draw transparency ---
  finalizeRequestId: BigInt
  selectedProvider: Bytes
  soldAtDrawing: BigInt
  drawRequestedAt: BigInt
  finalizedAt: BigInt
  finalizedTxHash: Bytes

  # --- winner transparency ---
  winner: Bytes
  winningTicketIndex: BigInt
  completedAt: BigInt
  winnerTxHash: Bytes

  # --- cancel transparency ---
  canceledReason: String
  soldAtCancel: BigInt
  potRefund: BigInt
  canceledAt: BigInt
  canceledTxHash: Bytes

  # --- funding transparency ---
  fundingConfirmedAt: BigInt
  fundingConfirmedTxHash: Bytes

  # --- indexing metadata ---
  indexedAtBlock: BigInt!
  indexedAtTimestamp: BigInt!
  lastEventId: ID
}

type FactoryConfig @entity {
  id: Bytes!
  owner: Bytes!

  # defaults emitted by ConfigUpdated
  usdc: Bytes!
  entropy: Bytes!
  entropyProvider: Bytes!
  feeRecipient: Bytes!
  protocolFeePercent: BigInt!

  updatedAtBlock: BigInt!
  updatedAtTimestamp: BigInt!
  updatedTxHash: Bytes
}

type RegistryConfig @entity {
  id: Bytes!
  owner: Bytes!
  totalRegistered: BigInt

  updatedAtBlock: BigInt!
  updatedAtTimestamp: BigInt!
  updatedTxHash: Bytes
}

type RegistrarAuthorization @entity {
  id: ID!
  registry: Bytes!
  registrar: Bytes!
  authorized: Boolean!

  updatedAtBlock: BigInt!
  updatedAtTimestamp: BigInt!
  txHash: Bytes!
}

type RaffleEvent @entity {
  id: ID!
  raffle: Bytes!
  kind: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  txHash: Bytes!

  # optional payloads (kept flexible)
  buyer: Bytes
  count: BigInt
  totalCost: BigInt
  totalSold: BigInt

  requestId: BigInt
  provider: Bytes

  winner: Bytes
  winningTicketIndex: BigInt

  canceledReason: String
  potRefund: BigInt
  ticketRevenue: BigInt

  oldOwner: Bytes
  newOwner: Bytes
}